// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

interface IERC20HMM {
    function depositors() external view returns(uint256);
    function deposits(address _address) external view returns(uint256);
    function depositorID(address _address) external view returns(uint256);
    function idToDepositor(uint256 _id) external view returns(address);
}

interface IHmmTreasurer {
    function count() external view returns(uint256);
    function getInfos(uint256 _id) external view returns(uint8 sens, address token, uint256 strike, uint256 expiration, uint256 amount, int256 loss, bool executed);
    function getHmmInfos() external view returns(uint256 OI, uint256 value, int256 temporaryLoss, int256 loss);
    function reimburseHmmLoss(int256 _loss) external;
}

/*
 * @title Treasurer contract
 * @notice This contract allows to receive the gains generated by the liquidity providers and to distribute them equitably
 */
contract Treasurer {

    uint256 decimals = 10**18;

    address constant WETH = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;
    address public immutable HMM;
    address public immutable ERC20HMM;
    address public immutable Voucher;

    uint256 public rewardsDispatched;

    struct receiptInfos {
        uint256 receivedAmount;
        uint256 dateReceived;
        uint256 dateExpiration;
        uint256 finallyProvided;
        bool finalized;
    }

    mapping(uint256 => receiptInfos) private _receiptInfo;
    mapping(address => uint256) private _lpRewards;

    constructor(address _erc20HmmAddress, address _voucher) {

        HMM = msg.sender;
        ERC20HMM = _erc20HmmAddress;
        Voucher =_voucher;

        IERC20(WETH).approve(msg.sender, 2**255);        

    }

     modifier onlyHmm() {
        require(msg.sender == HMM, "Ownable: caller is not the owner");
        _;
    }

    /*
     * @notice Returns all rewards distributed to LPs since the creation of the smart contract
     */
    function getAllRewards() public view returns(uint256) {
        uint256 receivedAmount;
        uint256 age;
        uint256 duration;
        uint256 rewards;

        for(uint256 i = 0 ; i < IHmmTreasurer(HMM).count() ; i++) {
            if (_receiptInfo[i].finalized == true) {
                rewards += _receiptInfo[i].finallyProvided;
            } else {
                receivedAmount = _receiptInfo[i].receivedAmount;
                age = block.timestamp - _receiptInfo[i].dateReceived;
                duration = _receiptInfo[i].dateExpiration - _receiptInfo[i].dateReceived;
                if (age < duration) {
                    rewards += (receivedAmount * ((age * decimals)/ duration)) / decimals;
                } else {
                    rewards += receivedAmount;
                }
            }
        }

        return rewards;
    }

    /*
     * @notice Returns rewards that can be made "claimable" by LPs
     */
    function restToDispatch() public view returns(uint256) {
        (,,,int256 hmmLoss) = IHmmTreasurer(HMM).getHmmInfos();

        uint256 dispatchable = getAllRewards() - rewardsDispatched;

        if (hmmLoss > 0) {
            if (dispatchable <= uint256(hmmLoss)) {
                return 0;
            } else {
                return dispatchable - uint256(hmmLoss);
            }
        } else {
            return dispatchable;
        }

    }

    /*
     * @notice Makes the latest LP rewards claimable
     */
    function dispatch() public {

        uint256 rewards = restToDispatch();

        //need to refund the HMM ?
        (,,,int256 hmmLoss) = IHmmTreasurer(HMM).getHmmInfos();
        uint256 dispatchable = getAllRewards() - rewardsDispatched;

        if (hmmLoss > 0 && dispatchable > uint256(hmmLoss)) {

            IERC20(WETH).transfer(HMM, uint256(hmmLoss));
            IHmmTreasurer(HMM).reimburseHmmLoss(hmmLoss);

        }

        address payee;
        uint256 shares;
        uint256 amountForPayee;

        for(uint i = 1 ; i <= IERC20HMM(ERC20HMM).depositors(); i++) {
            payee = IERC20HMM(ERC20HMM).idToDepositor(i);
            shares = sharesOf(payee);
            amountForPayee = (rewards*shares)/decimals;
            _lpRewards[payee] += amountForPayee;
        }

        rewardsDispatched += restToDispatch();
    
    }

    /*
     * @notice Called by the HMM when creating a new option contract
     */
    function receivePremium(uint256 _id, uint256 _amount) external onlyHmm {

        (,,, uint256 expiration,,,) = IHmmTreasurer(HMM).getInfos(_id);

        receiptInfos memory newReceipt = receiptInfos(_amount, block.timestamp, expiration, 0, false);

        _receiptInfo[_id] = newReceipt;

    }

    /*
     * @notice Returns the rewards claimable by the user
     * @param _user Refers to the address of the LP
     */
    function rewardAvailable(address _user) public view returns(uint256) {
        uint256 actualRewards = _lpRewards[_user];
        uint256 nextRewards = (restToDispatch()*sharesOf(_user))/decimals;
        return actualRewards + nextRewards;
    }

    /*
     * @notice Returns the remaining amount of the originally deposited premium that has not yet been sent to the LPs
     * @param _id The option id
     */
    function getRest(uint256 _id) external view returns(uint256) {
        uint256 receivedAmount = _receiptInfo[_id].receivedAmount;
        uint256 age = block.timestamp - _receiptInfo[_id].dateReceived;
        uint256 duration = _receiptInfo[_id].dateExpiration - _receiptInfo[_id].dateReceived;
        uint256 provided;

        if (age >= duration) {
            provided = receivedAmount;
        } else {
            provided = (receivedAmount * ((age * decimals)/ duration)) / decimals;
        }           
        
        uint256 restToProvide = receivedAmount - provided;

        return restToProvide;
    }

    /*
     * @notice Returns the information retained by the Treasurer regarding a specific option contract
     * @param _id The option id
     */
    function getReceiptInfos(uint256 _id) external view returns(uint256 receivedAmount, uint256 dateReceived, uint256 dateExpiration, uint256 finallyProvided, bool finalized) {
        return (_receiptInfo[_id].receivedAmount, _receiptInfo[_id].dateReceived, _receiptInfo[_id].dateExpiration, _receiptInfo[_id].finallyProvided, _receiptInfo[_id].finalized);
    }

    /*
     * @notice Called by the HMM to reimburse an option buyer
     * @param _id The option id
     */
    function reimburse(uint256 _id) external onlyHmm returns(int256) {

        uint256 receivedAmount = _receiptInfo[_id].receivedAmount;
        uint256 age = block.timestamp - _receiptInfo[_id].dateReceived;
        uint256 duration = _receiptInfo[_id].dateExpiration - _receiptInfo[_id].dateReceived;
        uint256 provided;

        if (age >= duration) {
            provided = receivedAmount;
        } else {
            provided = (receivedAmount * ((age * decimals)/ duration)) / decimals;
        }           
        
        uint256 restToProvide = receivedAmount - provided;

        (,,,,,int loss,) = IHmmTreasurer(HMM).getInfos(_id);

        if (int256(restToProvide) - loss >= 0) {
            if(loss >= 0) {
                IERC20(WETH).transfer(IERC721(Voucher).ownerOf(_id), restToProvide - uint256(loss));
                IERC20(WETH).transfer(HMM, uint256(loss));

                _receiptInfo[_id].finallyProvided = provided;
                _receiptInfo[_id].finalized = true;
                return 0;
            } else {
                IERC20(WETH).transfer(IERC721(Voucher).ownerOf(_id), restToProvide);

                _receiptInfo[_id].finallyProvided = provided;
                _receiptInfo[_id].finalized = true;
                return loss;
            }            
        } else {
            IERC20(WETH).transfer(HMM, restToProvide);

            _receiptInfo[_id].finallyProvided = provided;
            _receiptInfo[_id].finalized = true;
            return loss - int256(restToProvide);
        }
    }

    /*
     * @notice Returns the proportion of liquidity held by an address (1x10**18 for 100%)
     */
    function sharesOf(address _payee) public view returns(uint256) {
        if(IERC20(ERC20HMM).totalSupply() > 0) {
            return (IERC20(ERC20HMM).balanceOf(_payee)*decimals)/IERC20(ERC20HMM).totalSupply();
        } else {
            return 0;
        }
        
    }

    /*
     * @notice Allow liquidity providers to claim their rewards
     */
    function claim() external {
        require(rewardAvailable(msg.sender) != 0, "No rewards available");

        dispatch();

        uint256 rewards = _lpRewards[msg.sender];

        IERC20(WETH).transfer(msg.sender, rewards);

        _lpRewards[msg.sender] = 0;
        
    }

}

